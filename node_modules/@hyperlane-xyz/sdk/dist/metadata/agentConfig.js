"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAgentConfigDeprecated = exports.buildAgentConfig = exports.ChainMetadataForAgentSchema = exports.AgentMetadataExtSchema = exports.AgentConnectionType = void 0;
const zod_1 = require("zod");
const deploymentArtifacts_1 = require("./deploymentArtifacts");
/**
 * New agent config shape that extends the existing chain metadata with agent-specific fields.
 */
var AgentConnectionType;
(function (AgentConnectionType) {
    AgentConnectionType["Http"] = "http";
    AgentConnectionType["Ws"] = "ws";
    AgentConnectionType["HttpQuorum"] = "httpQuorum";
    AgentConnectionType["HttpFallback"] = "httpFallback";
})(AgentConnectionType = exports.AgentConnectionType || (exports.AgentConnectionType = {}));
exports.AgentMetadataExtSchema = zod_1.z.object({
    rpcConsensusType: zod_1.z
        .nativeEnum(AgentConnectionType)
        .default(AgentConnectionType.HttpFallback)
        .describe('The consensus type to use when multiple RPCs are configured. `fallback` will use the first RPC that returns a result, `quorum` will require a majority of RPCs to return the same result. Different consumers may choose to default to different values here, i.e. validators may want to default to `quorum` while relayers may want to default to `fallback`.'),
    overrideRpcUrls: zod_1.z
        .string()
        .optional()
        .describe('Used to allow for a comma-separated list of RPC URLs to be specified without a complex `path` in the agent configuration scheme. Agents should check for the existence of this field first and use that in conjunction with `rpcConsensusType` if it exists, otherwise fall back to `rpcUrls`.'),
    index: zod_1.z.object({
        from: zod_1.z
            .number()
            .default(1999)
            .optional()
            .describe('The starting block from which to index events.'),
        chunk: zod_1.z
            .number()
            .default(1000)
            .optional()
            .describe('The number of blocks to index per chunk.'),
    }),
});
exports.ChainMetadataForAgentSchema = deploymentArtifacts_1.ChainMetadataWithArtifactsSchema.merge(exports.AgentMetadataExtSchema);
function buildAgentConfig(chains, multiProvider, addresses, startBlocks) {
    const configs = {};
    for (const chain of [...chains].sort()) {
        const metadata = multiProvider.getChainMetadata(chain);
        const config = Object.assign(Object.assign({}, metadata), { rpcConsensusType: AgentConnectionType.HttpFallback, mailbox: addresses[chain].mailbox, interchainGasPaymaster: addresses[chain].interchainGasPaymaster, validatorAnnounce: addresses[chain].validatorAnnounce, index: {
                from: startBlocks[chain],
            } });
        configs[chain] = config;
    }
    return configs;
}
exports.buildAgentConfig = buildAgentConfig;
function buildAgentConfigDeprecated(chains, multiProvider, addresses, startBlocks) {
    var _a, _b;
    const agentConfig = {
        chains: {},
    };
    for (const chain of [...chains].sort()) {
        const metadata = multiProvider.getChainMetadata(chain);
        const chainConfig = {
            name: chain,
            domain: metadata.chainId,
            addresses: {
                mailbox: addresses[chain].mailbox,
                interchainGasPaymaster: addresses[chain].interchainGasPaymaster,
                validatorAnnounce: addresses[chain].validatorAnnounce,
            },
            protocol: metadata.protocol,
            finalityBlocks: (_b = (_a = metadata.blocks) === null || _a === void 0 ? void 0 : _a.reorgPeriod) !== null && _b !== void 0 ? _b : 1,
        };
        chainConfig.index = {
            from: startBlocks[chain],
        };
        agentConfig.chains[chain] = chainConfig;
    }
    return agentConfig;
}
exports.buildAgentConfigDeprecated = buildAgentConfigDeprecated;
//# sourceMappingURL=agentConfig.js.map