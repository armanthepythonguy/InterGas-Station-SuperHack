"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneCoreDeployer = void 0;
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const core_1 = require("@hyperlane-xyz/core");
const HyperlaneDeployer_1 = require("../deploy/HyperlaneDeployer");
const contracts_1 = require("./contracts");
class HyperlaneCoreDeployer extends HyperlaneDeployer_1.HyperlaneDeployer {
    constructor(multiProvider, ismFactory) {
        super(multiProvider, contracts_1.coreFactories, {
            logger: (0, debug_1.default)('hyperlane:CoreDeployer'),
            chainTimeoutMs: 1000 * 60 * 10, // 10 minutes
        });
        this.ismFactory = ismFactory;
        this.startingBlockNumbers = {};
    }
    deployTimelock(chain, delay, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const timelock = yield this.deployContract(chain, 'timelockController', 
            // see https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController-constructor-uint256-address---address---address-
            // delay, [proposers], [executors], admin
            [delay, [owner], [owner], ethers_1.ethers.constants.AddressZero]);
            return timelock;
        });
    }
    deployMailbox(chain, ismConfig, proxyAdmin, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedMailbox = this.readCache(chain, this.factories.mailbox, 'mailbox');
            if (cachedMailbox) {
                // let checker/governor handle cached mailbox default ISM configuration
                // TODO: check if config matches AND deployer is owner?
                return cachedMailbox;
            }
            const defaultIsmAddress = yield this.deployIsm(chain, ismConfig);
            const domain = this.multiProvider.getDomainId(chain);
            return this.deployProxiedContract(chain, 'mailbox', proxyAdmin, [domain], [owner, defaultIsmAddress]);
        });
    }
    deployValidatorAnnounce(chain, mailboxAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const validatorAnnounce = yield this.deployContract(chain, 'validatorAnnounce', [mailboxAddress]);
            return validatorAnnounce;
        });
    }
    deployIsm(chain, config) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger(`Deploying new ISM to ${chain}`);
            const ism = yield this.ismFactory.deploy(chain, config);
            return ism.address;
        });
    }
    deployContracts(chain, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (config.remove) {
                // skip deploying to chains configured to be removed
                return undefined;
            }
            this.startingBlockNumbers[chain] = yield this.multiProvider
                .getProvider(chain)
                .getBlockNumber();
            const proxyAdmin = yield this.deployContract(chain, 'proxyAdmin', []);
            const mailbox = yield this.deployMailbox(chain, config.defaultIsm, proxyAdmin.address, config.owner);
            const validatorAnnounce = yield this.deployValidatorAnnounce(chain, mailbox.address);
            let timelockController;
            if (config.upgradeTimelockDelay) {
                timelockController = yield this.deployTimelock(chain, config.upgradeTimelockDelay, config.owner);
                yield this.transferOwnershipOfContracts(chain, timelockController.address, { proxyAdmin });
            }
            else {
                // mock this for consistent serialization
                timelockController = core_1.TimelockController__factory.connect(ethers_1.ethers.constants.AddressZero, this.multiProvider.getProvider(chain));
                yield this.transferOwnershipOfContracts(chain, config.owner, {
                    mailbox,
                    proxyAdmin,
                });
            }
            return {
                mailbox,
                proxyAdmin,
                timelockController,
                validatorAnnounce,
            };
        });
    }
}
exports.HyperlaneCoreDeployer = HyperlaneCoreDeployer;
//# sourceMappingURL=HyperlaneCoreDeployer.js.map