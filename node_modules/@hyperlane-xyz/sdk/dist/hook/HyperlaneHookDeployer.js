"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneHookDeployer = void 0;
const debug_1 = __importDefault(require("debug"));
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils/dist/src/utils");
const HyperlaneDeployer_1 = require("../deploy/HyperlaneDeployer");
const config_1 = require("./config");
const contracts_1 = require("./contracts");
class HyperlaneHookDeployer extends HyperlaneDeployer_1.HyperlaneDeployer {
    constructor(multiProvider) {
        super(multiProvider, contracts_1.hookFactories, {
            logger: (0, debug_1.default)('hyperlane:HookDeployer'),
        });
    }
    deploy(configMap) {
        return __awaiter(this, void 0, void 0, function* () {
            let ismContracts;
            let hookContracts;
            // Process ISM configs first
            for (const [chain, config] of Object.entries(configMap)) {
                if ((0, config_1.isISMConfig)(config)) {
                    ismContracts = yield this.deployContracts(chain, config);
                }
            }
            // Ensure ISM contracts have been deployed
            if (!ismContracts || !(ismContracts === null || ismContracts === void 0 ? void 0 : ismContracts.optimismISM)) {
                throw new Error('ISM contracts not deployed');
            }
            // Then process hook configs
            for (const [chain, config] of Object.entries(configMap)) {
                if ((0, config_1.isHookConfig)(config)) {
                    config.remoteIsm = ismContracts.optimismISM.address;
                    this.logger(`Remote ISM address set as ${config.remoteIsm}`);
                    hookContracts = yield this.deployContracts(chain, config);
                }
            }
            // Ensure hook contracts have been deployed
            if (!hookContracts || !(hookContracts === null || hookContracts === void 0 ? void 0 : hookContracts.optimismMessageHook)) {
                throw new Error('Hook contracts not deployed');
            }
            const hookAddress = hookContracts.optimismMessageHook.address;
            this.logger(`Setting hook address ${hookAddress} for OptimismISM`);
            yield ismContracts.optimismISM.setOptimismHook(hookAddress);
            const deployedContractMap = {
                optimismISM: ismContracts.optimismISM,
                testRecipient: ismContracts.testRecipient,
                optimismMessageHook: hookContracts.optimismMessageHook,
            };
            return deployedContractMap;
        });
    }
    deployContracts(chain, hookConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            let optimismISM, optimismMessageHook, testRecipient;
            this.logger(`Deploying ${hookConfig.hookContractType} on ${chain}`);
            if ((0, config_1.isISMConfig)(hookConfig)) {
                optimismISM = yield this.deployOptimismISM(chain, hookConfig.nativeBridge);
                testRecipient = yield this.deployTestRecipient(chain, optimismISM.address);
                this.logger(`Deployed test recipient on ${chain} at ${(0, utils_1.addressToBytes32)(testRecipient.address)}`);
                return {
                    optimismISM,
                    testRecipient,
                };
            }
            else if ((0, config_1.isHookConfig)(hookConfig)) {
                optimismMessageHook = yield this.deployOptimismMessageHook(chain, hookConfig.destinationDomain, hookConfig.nativeBridge, hookConfig.remoteIsm);
                return {
                    optimismMessageHook,
                };
            }
            return {};
        });
    }
    deployOptimismISM(chain, nativeBridge) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.multiProvider.getSigner(chain);
            const optimismISM = yield new core_1.OptimismISM__factory(signer).deploy(nativeBridge);
            yield this.multiProvider.handleTx(chain, optimismISM.deployTransaction);
            this.logger(`Deployed OptimismISM on ${chain} at ${optimismISM.address}`);
            return optimismISM;
        });
    }
    deployTestRecipient(chain, ism) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.multiProvider.getSigner(chain);
            const testRecipient = yield new core_1.TestRecipient__factory(signer).deploy();
            yield this.multiProvider.handleTx(chain, testRecipient.deployTransaction);
            yield testRecipient.setInterchainSecurityModule(ism);
            return testRecipient;
        });
    }
    deployOptimismMessageHook(chain, destinationDomain, nativeBridge, optimismISM) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.multiProvider.getSigner(chain);
            const optimismMessageHook = yield new core_1.OptimismMessageHook__factory(signer).deploy(destinationDomain, nativeBridge, optimismISM);
            yield this.multiProvider.handleTx(chain, optimismMessageHook.deployTransaction);
            this.logger(`Deployed OptimismMessageHook on ${chain} at ${optimismMessageHook.address}`);
            return optimismMessageHook;
        });
    }
}
exports.HyperlaneHookDeployer = HyperlaneHookDeployer;
//# sourceMappingURL=HyperlaneHookDeployer.js.map